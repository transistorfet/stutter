
	* make all the colour mappings reassignable
	* split errors into multiple categories such as CRITICAL, MAJOR, MINOR, ???
	* go through all printed strings and allow them to contain variables (and thus themed colours).

	* extract the fe.c stuff into a new single widget that can contain the frame, statusbar, and input
	* decide on the behaviour for next/prev/current/etc in fe.c

	* make a set of initialization macros that can handle generic variable types.  At the very least
	  such that there is a seperate list for each type but the same macros used for each type.

	* go through everything and add lots of joinpoints

	* make a common way of initializing a widget (an array of option name/value pairs perhaps)
	* how can you control a list widget such as a users list where names are added and deleted?  should
	  the widget rely on an array to get it's information?  should the widget be a vairable array itself?
	  should the whole widget structure be replicated as variables such that every widget is added to
	  the variables list using the id as it's name?

Structural Issues:
	* the current/select functions can use the context as a partial type name lookup such that there
	  are special context names which correspond to special object "superclasses" such as 'frame' and
	  'input'.  Then when you specify something like 'frame' as the context, it means a general type of
	  widget.  ???
	* is there a better name for scroll.c?

	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h
	* should the stringify and evaluate type functions take a parameter (string or number?) to specify
	  the "type" of operation?  This for example, would let you get the real value and formatted value
	  of a format type or to specify the context of evaluation to avoid the /parse issue. 
	* should you make bind_key take a command and args pair instead of a void *, type * and args pair
	  so that you wont have an issue with variables bound to keys being removed
	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?) (a function in signals to delete
	  all signal handlers with a reference to a particular pointer?  will this possibly delete things
	  that its not suppose to since the pointer is not necessarily an address?).  Another possibility is
	  sending an optional destroy function that can is called when a type is destroyed.  For things
	  where the pointer may be used multiple times but still needs to be destroyed, a simple refcount
	  can be used in the pointer and the destroy func.

	* should we change fe_read to return an int instead of char *?
	* how will you draw the cursor? draw it yourself using a reverse colour attribute in the widget
	  refresh itself (thus it would be cross platform)?
	* use the type system for widget types.  A widget is created from a type and subwidgets are added
	* how will widgets (like statusbar) be added, stored, accessed?  Will it be entirely frontend
	  specific or will it be through the variable system in which case a widget would be a variable
	  of the "widget" type.
	* should you add a bunch of variables to the frontends which return common environment variables
	  and values such as the homedir and the current user's username?  should there also be a way to
	  access environment variables through a function and how would that be supported?

	* what if you store the channel struct pointer as the index?  there can be an irc-specific
	  method of finding the channel by assuming the index of an "irc.print" signal (or whatever it
	  will be called) is a channel struct but it would still need a method of searching all signal
	  handlers for "irc.print" for the current window pointer stored as the signal handler's
	  parameter.
	* should irc_send_msg dispatch the message (and thus dispatch all outbound messages? instead of just
	  dispatching select messages like privmsg and notice (which would require a rewrite of the message
	  handlers to check for an outbound message))

	* should the libs/ be moved to the root dir (since the primary issue was all the headers but now
	  that they are all inside include/stutter/ they wont conflict with system headers).
	* a window handler connecting to a signal emitted for a particular window so that it can
	  free memory when that window is destroyed for example (server registering for its status
	  window and if a command like /close causes that window to be destroyed, the server disconnects
	  and frees all resources it uses)

Bugs:
	* there is a bug such that if you try to say something in the status window, the server says no such
	  nick
	* the windows version sometimes hangs up when printing the motd and wont change the display but you
	  can still type and the statusbar updates.
	* the bold_test string only displays white in bold even though the other colours can be bolded
	* when a character that is displayed with 2 characters is entered (such as ^C) the cursor is only
	  moved one character forward so when you enter more characters, they show up in further to the left
	  than expected
	* when you create a window ("base", "window", NULL, NULL) during the init before you run the dotfile
	  script and then switch to that first window from the server status window before joining a channel
	  and switch back to the irc status window, the nick and current channel don't change back among
	  other things

	* stutter does not detect and reconnect upon a read error: connection reset by peer

General:
	* revise dispatch to handle messages better during a reconnect
	* move the commmon/utils headers to the include/ dir

	* add scroll message handlers to the win32 frontend and use joinpoints to define the behaviour
	* make an init.c file for frontends with the init_frontend and release_frontend code
	* we can use fe_resize to resize the root widget for a surface thus taking care of the resize issue.
	  Where would the resize take place?  During refresh?  
	* fix up colour handling in curses/terminal.c (the add colour pair stuff)
	* make the calling of process_char() a joinpoint?

	* MAKE SURE all message handlers don't clobber the message! (CTCP messages do)
	* make an unknown ctcp message handler
	* implement execute.c for win32
	* add a function fe_prompt(char *prompt, char *buffer, int max) that prompts the user for input
	  by some appropriate frontend method (to be used for example to prompt yes or no when quitting)
	* add a flag option to the quit command that causes it to prompt yes/no before quitting

	* report when a command fails
	* fix up error handling in net.c and server.c
	* add error messages to commands and stuff that fail giving the reason for failure (this should
	  either be directly printed or use a different error joinpoint).
	* add a timer response type and make an email checker timed event
	* add a handler for irc message 433 (Nickname in use) which automagically changes the nick
	* make the MODE msg handler update the channel and user mode bits
	* add irc variables and types in a similar fashion to the colour type in the frontend

	* add dcc support
	* have an "activity" status indicator in the status bar so you know when stuff has been said and
	  in what channels
	* have keybindings for targeting specific windows (does this require window numbers?)
	* get realname, nick from current user's info (on unix) (store in a "realname" variable?)
	* pass realname to server when connecting (base it on a "realname" variable?)
	* add list command
	* add channel and user mode bits
	* add home/end functions to be keybound
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)
	* add unalias command

	* make ping to milliseconds
	* make a directory of configs for runtime configuration files
	* do better parsing of arguments in execute.c
	* move include files into an include/ directory inside of each module's directory (and then same
	  for frontends) (??? is this really a good idea?)
	* make a configuration/compilation script that builds the makefiles
	* modify channel.c to use a hash table instead of the linear list?
	* rewrite msg.c using va_args instead of making an array and use sprintf
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)
	* add a function to key.c to get the current binding of a key sequence (without processing)
	* make the common frontend stuff into a library that is compiled seperately
	* can you make the frontend colour type common colour names system a little nicer and fuller?

	* unify the naming patterns for variables and frontend widgets, etc.
	* can we fix the handling of the no remove flag in variables so that is doesn't remove the node
	  from the list before checking the flag and readding it when it finds it's not suppose to remove it?
	* would it be desirable to have msgs/names.c instead of ignoring users already added, update their
	  stats?  would this erase other bitflags that may have been set if they were just overwritten?
	* optimize for space and speed (re-evaluate things).
	* add the slab allocator
	* catch the ^C signal to cancel a connect
	* rewrite the simple frontend?

Features:
	* logging plugin
	* winamp control and display plugin
	* add dcc support
	* ability to reorder windows
	* skins for frontends

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)


