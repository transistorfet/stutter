
	* add a handler for the purge_object signal that deletes the object from the signal list in signal.c
	  (this requires a purge_object with a NULL object signal to be emitted)
	* figure out how the add_signal function will work with the new object thing

	* consider converting bitflags to bitfield structs unioned with the bitflags (so that it's still
	  easy to copy them).
	* convert all lists to use a more descriptive name than "data" as the data portion of the node
	* consider converting code to use contants and enums for some of the things that aren't configs
	* convert code to use the new offset_after_struct_m macro
	* you could have a special widget control command that allows you to add layouts to the widget
	  (basically have the widget process the layout for things like menus and stuff) and a bitflags in
	  the type of the layout that tells the layout generator to pass the layout to the widget instead of
	  calling the function, gettings a widget, and using the add widget command

	* make a header in frontend/common that has static inline functions for all the API function that
	  fe.c can use thus allowing you to maintain a single common implementation for all frontends that
	  use the common fe system
	* you can have a command "fe.dialogue <diag-name> <params>" in the win32 frontend that pops up a
	  dialogue by the given name (stored in a list probably by a dialogue.c manager in the core)

	* how is the win32 config defs going to work?
	* win32 is segfaulting when you close a window using the X button because the surface is not removed
	  from the fe.c surfaces_list.  This can be done either by having a central surfaces list that
	  terminal can call to destroy itself or by emitting a purge_object signal that fe.c can connect to
	* make dispatch into a whole bunch of joinpoints? (what dispatch am i talking about?)  Oh i think
	  this is related to the evaluating of commands based on signals (make irc dispatch into joinpoints
	  with the default joinpoint being the message handler
	* you need to re-evaluate the whole config system.  The biggest fuckup is with things that take
	  multiple options like lists of commands and joinpoints and such.  A perl script of some sort might
	  be useful for configuring these.  (as well as for enabling/disabling features)

	* what should be used as a reference to a layout (name, etc)?  what methods of describing layouts
	  will there be?  (hard-coded, xml, etc)? and how will they be expressed to layout?
	* implement the layout method of registering "type" creation functions and make a callback for
	  surfaces that calls something in fe.c as well as a callback for win32 terminal to create a menu.
	* how will you specify things like "create a text widget and add it to the current frame"?  Who will
	  add the widget to the frame, how does it know to do that, and how will it have access to that?
	  (Will the surface be resolved and the root widget of that surface passed to layout which makes
	  the widget and does whatever it needs to with the root widget it has been given?)
	* move layout changes to curses/fe.c to win32/fe.c
	* where should the xml parser go?  in the frontend or the core?

	* add a signal handler that connects to things like irc_dispatch_msg and executes commands when
	  particular messages come in.  You could even use some FEAT_ configs inside of this handler which
	  enable and disable features like reading a variable to get a list of commands to execute, and
	  sending a new uniquie signal for the message (wouldn't this belong in dispatch? or another signal
	  handler?)
	* you could have special variable tables like irc.on_msg where you add variables that are commands
	  and when a message comes in, it traverses all the variables in the table and evaluates them with
	  a particular formulation of parameters.  So you'd "/alias irc.on_msg.respond irc.say hey man"
	  to have it send "hey man" whenever you get a message.

	* should we disallow widgets to have the same id?  should we allow multiple ids and always add a
	  unique numbered id?  (this could cause a problem with the widget remove which at the moment uses
	  the id to find the widget).
	* can we add something to the hash/linear/etc lists that allowing you to find multiple entires with
	  the same "key"
	* add purge_object handlers for windows used in servers and channels
	* add a /close command that destroys a widget
	* if the changes to signal.c will include an optional index parameter then signal.c should make sure
	  it connects to object destroy signals such that handlers that use an index are purged when the
	  object of the index is destroyed.

	* attempt to canonicalize everything (you have sort of drifted in your style through-out this project)

	* the context is ignored in select/next/previous/etc but should it be? Should the behave like
	  the CURRENT_WIDGET command in region.c?  Change all the widget and fe.c functions
	* region rejects widgets being added before we've resized it but that is causing some troubles with
	  initialization (you have to make region a non-zero size before adding widget).  Should region
	  instead allow widgets to be added when they don't fit or should you just size region before the
	  terminal resizes it properly?

	* KEEP IN MIND: the frontend API is mean to abstract as much of the frontend away as possible.  The
	  formatting and display should be seperated from the core program
	* All widgets are owned by a surface or by other widgets.  A widget with no parent is owned by a
	  surface.  Surfaces can be owned by other surfaces (or possibly by widgets).  A surface with no
	  parent is controlled by the central list.

	* add to timer the ability to expire a timer prematurely

	* would it be totally bad to accept the parameters to emit as a va_list and store them in an array
	  of pointers that is passed to the handlers along with the size of the array?  Would this make
	  things to specific to a particular signal that is handled?  Is that a bad thing?

	* make bind key do the variable lookup itself but if you do, should you allow a path index lookup
	  or force all lookups to be absolute.  If you do that, you can still do path lookups by having
	  the /bind command use path.<name> for the command name (at least if no . is found).

	* it might be possible to make it so that every server has it's own frame of channel widgets and
	  when you use the next command, it will find the current frame, find the next text widget in that
	  frame, and if there is no next widget, instead of going to the first, it finds the next frame
	  (which should go to the next frame or go to the same frame if there is only one) and then go
	  to the first text widget in that frame.

	* work on API documentation
	* finish/fix up region particularily the handling of MODIFY_SIZE and possibly re-write split
	* finish the fe_resize implementation in fe.c

	* you kind of need a widget that is a list of widget/terminal pairs that handles everything itself
	  (taking away some responsibility of fe.c) so that you have a widget that can be an absolute root
	  that is the parent of all seperate windows/terminals.  (A dedicated list in fe.c wouldn't work
	  since the widgets need something to put as their parent unless fe.c was itself a widget).  You
	  could make the list a void * and type pair which means it can be tied to the variable tree but it
	  doesn't have to be.  The list widget would then want to do a traverse and stringify for each entry
	  which hopefully would do what is wanted.
	* should a WCC_SET_SURFACE also cause a resize of everything in region?  at least if it is the root
	  or is it the job of the code that sets the surface to also do a resize?

Structural Issues:
	* should windows be able to have 2 or more names ("#philosophy", "1", "otherside/#philosophy") or
	  should it be able to have only one name and a number which can be easily changed so that windows
	  can be accessed by number and the order can be switched. (or both?)  Could we have all the names
	  in one string like "otherside/#philosophy,#philosophy".  It probably is possible to do this using
	  multiple entries for the same node in the table and using strstr or something to compare the names
	  after the hash number has been found.
	* where should errors generally be printed from even using joinpoints?  Is it ok to have the net
	  code printing errors (in the case of the retries there isn't *that* much choice but perhaps there
	  is).  Would it be better for the command that attempts to connect to report the failure to connect
	  or should net_connect do that before it returns NULL?  (For example, the net.c's failed to connect
	  message is always printed before the unable to reconnect message when stutter is disconnected from
	  irc.)

	* can anything be done about the sorta messiness of the joinpoints?
	* should joinpoint's default settings be defined inside the appropriate source file using an #ifndef
	  check?  If this was the case, every file would have to have its own joinpoint for something and
	  a global default value would still have to be around that the default values refer to
	* should you make bind_key take a command and args pair instead of a void *, type * and args pair
	  so that you wont have an issue with variables bound to keys being removed
	* should all instances of stringify that are accessable to the user do an index (path lookup) so
	  that all variables can be accessed indirectly and not just commands? (eg /get current_nick will
	  stringify "irc.current_nick")
	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h
	* should the stringify and evaluate type functions take a parameter (string or number?) to specify
	  the "type" of operation?  This for example, would let you get the real value and formatted value
	  of a format type
	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?) (a function in signals to delete
	  all signal handlers with a reference to a particular pointer?  will this possibly delete things
	  that its not suppose to since the pointer is not necessarily an address?).  Another possibility is
	  sending an optional destroy function that can is called when a type is destroyed.  For things
	  where the pointer may be used multiple times but still needs to be destroyed, a simple refcount
	  can be used in the pointer and the destroy func.
	* should you make a seperate include/ dir for each module/frontend?
	* should you add parameter names to all function prototypes?  what is the difference if any?
	* should we make net and exec be able to have a different callback for each different condition?
	  (read/write/error/etc).

	* should there be 2 region widgets (one handling horizontal and one vertical organization) or should
	  there be one that handles both directions (but not necessarily at the same time)?
	* the init functions for widgets should take parameters but how should those parameters be passed and
	  described? (ie. using vargs? passing a string with typenames or valuename?)
	* should we change fe_read to return an int instead of char *?
	* should you add a bunch of variables to the frontends which return common environment variables
	  and values such as the homedir and the current user's username?  should there also be a way to
	  access environment variables through a function and how would that be supported?
	* should the parameters to fe_resize be absolute sizes or differences in size?
	* what will happen to MODIFY_POSITION?  I can't see this being needed much but i guess it could be
	  so we could do the same thing as with MODIFY_SIZE
	* should there be a function in the fe that returns the id of a widget given a pointer to it?  Should
	  there be a way to change the id?  properties (such as title)?
	* how will multiple terminals work in curses?  how will input work with multiple terminal?
	* how can you control a list widget such as a users list where names are added and deleted?  should
	  the widget rely on an array to get it's information?  should the widget be a vairable array itself?
	  should the whole widget structure be replicated as variables such that every widget is added to
	  the variables list using the id as it's name?
	* should widget types be stored in a dedicated list or as a system variable

	* should irc_send_msg dispatch the message (and thus dispatch all outbound messages? instead of just
	  dispatching select messages like privmsg and notice (which would require a rewrite of the message
	  handlers to check for an outbound message))

	* can/should we make complex and/or expensive operations compile-time options (at least as long
	  as the operation can be disabled without causing trouble)? (like vim does with its FEAT_...)
	* should you move the commmon/utils headers to the include/ dir?

Bugs:
	* there is a bug such that if you try to say something in the status window, the server says no such
	  nick
	* the windows version sometimes hangs up when printing the motd and wont change the display but you
	  can still type and the statusbar updates.
	* when a character that is displayed with 2 characters is entered (such as ^C) the cursor is only
	  moved one character forward so when you enter more characters, they show up in further to the left
	  than expected
	* got some kind of infinite loop connected to freenode, in #logarithm, after testing logarithm with
	  stutter running on panther

	* stutter may be printing quit messages for users to channels where the user only partially matches
	  (logarithm_'s quit was reported when only logarithm was in the channel).
	* the Error Disconnected message is only printed for one server and is printed along with other
	  messages to the current window and not to windows properly associated with that server

General:
	* work on the new build system
	* convert some of the modules that use linear lists to use the static inlines version of it instead
	* fix text.c to properly display tab characters (perhaps you could modify irc_format_msg instead
	  to expand tabs and/or to filter out non-printable characters such as backspace and other control
	  codes)

	* add scrollwheel message handlers to the win32 frontend and use joinpoints to define the behaviour
	* fix up colour handling in curses/terminal.c (the add colour pair stuff)

	* add a string variable to the frontends to identify what frontend is compiled in
	* add a version string
	* implement execute.c for win32
	* add a function fe_prompt(char *prompt, char *buffer, int max) that prompts the user for input
	  by some appropriate frontend method (to be used for example to prompt yes or no when quitting)
	* add a flag option to the quit command that causes it to prompt yes/no before quitting
	* convert text.c and server.c/msg.c to use the new queue functions if it is easily possible
	* make everything unicode/UTF-8 capable
	* fix fonts in win32 fe (particularily adding the expression of the bold attribute)

	* add server name to notice messages
	* report when a command fails
	* make the disconnect error print to all windows instead of just the current one (using joinpoints)
	* add a timer response type and make an email checker timed event
	* add irc variables and types for servers and channels and so on in a similar fashion to the colour
	  type in the frontend

	* do better parsing of args in commands and such (so you can use "" in particular)
	* add dcc support
	* have an "activity" status indicator in the status bar so you know when stuff has been said and
	  in what channels
	* have keybindings for targeting specific windows (does this require window numbers?)
	* get realname, nick from current user's info (on unix) (store in a "realname" variable?)
	* pass realname to server when connecting (base it on a "realname" variable?)
	* add list command
	* add home/end functions to be keybound
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)
	* add unalias command
	* add a beep (maybe using an fe_beep() function which is called from irc_format_msg)?
	* add channel and user mode bit stringification (probably through some kind of variable type)

	* add UDP support to the net interface.
	* for each command write a proper description of the command's use in the source file itself either
	  as a comment or as a variable of some kind that is accessable to some kind of help system.
	* make ping do milliseconds
	* make a directory of configs for runtime configuration files
	* do better parsing of arguments in execute.c
	* make a configuration/compilation script that builds the makefiles
	* modify channel.c to use a hash table instead of the linear list?
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)
	* add a function to key.c to get the current binding of a key sequence (without processing)
	* can you make the frontend colour type common colour names system a little nicer and fuller?
	* add a prompt to the input widget that you can set through the variable system
	* make all the colour mappings reassignable
	* make an online help system

	* can we fix the handling of the no remove flag in variables so that is doesn't remove the node
	  from the list before checking the flag and readding it when it finds it's not suppose to remove it?
	* optimize for space and speed (re-evaluate things).
	* add the slab allocator
	* catch the ^C signal to cancel a connect
	* add a SIGWINCH handler to curses terminal

Features:
	* logging plugin
	* winamp control and display plugin
	* ability to reorder windows
	* skins for frontends

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)


