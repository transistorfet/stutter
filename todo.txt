
	* think about putting libnit code directly into stutter
	* where will the functions to stringify nick and current channel go? and where/how will they
	  be added to the variable database?
	* standardize the interpretation of the create type function parameters (the format string should
	  only ever contain a description of the arguments and should never be an argument itself)
	* the frontend initialization problem is not solved because the command and format types are
	  not available until after base_module is initialized
	* what will be the first parameter to the input function to be added in the frontend?  can we make
	  it work as a command type?  What do we send as the first parameter?
	* should variables have a reference to the namespace they are in?

	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h

	* add ping/whois commands
	* add a function that interpretes just string escapes for non-interpolated strings
	* catch the ^C signal and cancel a connect
	* make variables and namespaces case-insensitive
	* fix parse so that /parse something command doesn't cause a segfault
	* add channel and user mode bits
	* add handling for CTCP commands

	* add a function to key.c to get the current binding of a key sequence (without processing)
	* document the required frontend things widgets (like window, input), things that can be passed
	  to fe_current...

	* should i maintain a seperate changelog for each module, frontend, and the main program?
	* should i make a frontend/common directory?
	* how will xml be handled?
	* how will widgets be stored? as a variable with a special widget type? 
	* add home/end/erase-line functions to be keybound
	* make sure you can specify a certian window (by number for example)
	* add reconnect command
	* add error message handling
	* test multiserver functionality (more thuroughly?)
	* would it be desirable to have msgs/names.c instead of ignoring users already added, update their
	  stats?  would this erase other bitflags that may have been set if they were just overwritten?
	* add no-remove and no-change bitflags to variables (once they are set, they cannot be unset)
	* how will widgets (like statusbar) be added, stored, accessed?  Will it be entirely frontend
	  specific or will it be through the variable system in which case a widget would be a variable
	  of the "widget" type.
	* unify the naming patterns for namespace/variables, frontend widgets, etc.
	* can we remove the namespace module and have the namespace list included in variable?
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)

	* add a cmd that takes a string in env and a string in args, merges them, and parses/evaluates it
	  as a command without the leading /
	* add an alias command which creates a new command with the given name using the above command as
	  the function and the args string as the string parameter (to become env)
	* add an unalias command that removes a command only so long as it has the form of an alias (has
	  the function twice above as the callback)

	* can we remove libnit and put the code directly in stutter
	* rewrite namespace to use the new list thing or remove module
	* rewrite variable (?) to use new list thing
	* rewrite type to use the new list thing
	* rewrite key to use the new list thing

	* make a new more dynamic dispatcher (at least compile-time customizable)
	* do we need more functions for widget type? (create, destroy, clear, print, move, resize, refresh)
	* can we eliminate the need for lots of extra functions by using a byte encoded stream input to a
	  function like print with escape codes as well as meta data (somewhat like how you control a
	  terminal)

	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?)
	* rewrite msg.c using the new nit/string module and use va_args instead of making an array
	* there is a bug such that if you try to say something in the status window, the server says no such nick
	* the quit command is irc-specific but can it be made independant?

	* logging plugin
	* tab complete
	* winamp control and display plugin
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)
	* pass realname to server when connecting
	* get realname, nick from current user's info (on unix)

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)
	* can have xml/javascript/flash displayed from a script somewhat like firefox extensions (except
	  hopefully in less files?)
	* is it possible to display the output of a single channel on multiple windows by using a special
	  group-of-windows window that is stored in the channel struct and a call to print to this window
	  will call print on each window in its group?

	* is it faster to alloc a large string, copy data into it, and then realloc down (with only a slight
	  change of allocing up)?  or to alloc only a single string and copy a static buffer to it?
	* can variables be "watched" such that when the value changes, a function is called? (is this needed)
	* how would something like channel change be monitored so that a function can be called to
	  update a variable value?  (eg. to update the value of a variable that is used as the input prompt)
	* make an aspects toolkit that allows you to make joinpoints in the code easily and so on (using macros)

Possible Future Issues:
	* add widget param to fe_refresh so that single widgets can be refreshed instead of the whole screen
	* change name of _widget functions
	* possibly change variable names to be passed as a single string with the namespace and variable
	  name (seperated by a colon or something else) instead of being passed as 2 seperate strings.

