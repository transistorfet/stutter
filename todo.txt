
	* test traverse in variable.c

	* have modules make their tables and put their variable in them
	* tidy up the simple.c initialization (should we make it common for each frontend? at least key binds)
	* what can you call the directory where signal handlers for modules can be stored?
	* convert the status variable callbacks to take buffers intead of returning char *
	* add a signal that can be used to trigger things that are currently timed like statusbar refresh
	  (statusbar would need to be called ever time the time-var changes which could be really tricky)

Signals:
	* what if you store the channel struct pointer as the index?  there can be an irc-specific
	  method of finding the channel by assuming the index of an "irc-print" signal (or whatever it
	  will be called) is a channel struct but it would still need a method of searching all signal
	  handlers for "irc-print" for the current window pointer stored as the signal handler's
	  parameter.
	* can store a struct signal_s * (?) with the channel struct that the message handlers can then
	  use to emit that signal so that it goes to that channel (instead of having to build up the
	  name of the signal).

	* "channels" which can be directed to various windows and sources (perhaps it should be
	  controlled by the frontend so that a channel like "critical errors" can cause popup messages
	  whereas "normal errors" can print to the current window).
	* a way to call a signal handler when a parameter passed by the emitter matches (further
	  specifying a signal) (think net callbacks with the parameter being the socket)
	* with net callbacks, windows(OS) will pass a message to a window along with the socket which means
	  the network struct needs to first be looked up before a signal can be emitted for that network
	  struct (ie. first you do a lookup (net.c must have a table of network structs) and then you
	  emit the signal which does a hashtable lookup on the signal and then a table lookup on the
	  network struct to get the signal handlers (of which there is only likely to be 1)).  This is
	  instead of just a static callback stored in the network struct itself.  The only way I see to
	  overcome this is to use the socket to index the signal (in which case net.c would not store a list
	  of network structs for windows and gtk (but still for console)).  This however requires that the
	  callee knows to index based on the socket which is doesn't.  *This* can be overcome by using *only*
	  the socket and not having a network struct.  The one thing we loose with that is the saved read
	  buffer but then again you can have a private table of read buffers indexed by socket (hashtable
	  perhaps) in net.c
	* error handling using signals?  at least a string describing the specific error
	* a window handler connecting to a signal emitted for a particular window so that it can
	  free memory when that window is destroyed for example (server registering for its status
	  window and if a command like /close causes that window to be destroyed, the server disconnects
	  and frees all resources it uses)

Structural Issues:
	* should we add a mechanism to signals that allows for signals to "inherit" from others so that
	  when a signal is emitted (irc channel) it also triggers another signal (like "general_msg") or
	  something which might making logging easier?

	* should we make a dynamic dispatcher such that every message is turned into an individual signal?
	  should we use an added signal manager compare feature to dispatch all messages using a single
	  signal and the numeric command parameter?

	* can we fix the /parse issue by making it take the string as a param instead and have a signal
	  handler that is called when the key is pressed that acutally get the input and calls parse?
	* should you be able to reassign to a variable of an unknown type (ie. pass NULL as the type to
	  add_variable?
	* should we add a parent field to the variable?
	* how will you do timers?  they have to be implemented through the frontend.  Should a timeout
	  cause a signal to be emitted?  a callback (stored in the timer struct) to be called?
	* is there a fancy configurable way that the destination of printed messages is sent?  For example,
	  a way to specify that the names printed by the msgs/names.c file are sent to the current window,
	  the status window, and the appropriate channel window?
	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h
	* think about xml (possibly using a special char for <>) and what would acutally be done
	  (particularily with respect to irc_format_msg)
	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?) (a function in signals to delete
	  all signal handlers with a reference to a particular pointer?  will this possibly delete things
	  that its not suppose to since the pointer is not necessarily an address?) another possability is
	  to have a event/message/something signal handler for that pointer.
	* standardize the interpretation of the create type function parameters (the format string should
	  only ever contain a description of the arguments and should never be an argument itself)

	* there needs to be a generic (cross-frontend) way to represent keys
	* how will xml be handled?
	* how do you get the statusbar height in window.c
	* how are you going to deal with keys and screen size in the simple/screen.c module
	* is there a way to set the statusbar colour across the screen that is appropriately general without
	  using multiple frames and if not, use multiple frames in frontend/simple.
	* how will widgets (like statusbar) be added, stored, accessed?  Will it be entirely frontend
	  specific or will it be through the variable system in which case a widget would be a variable
	  of the "widget" type.
	* can we eliminate the need for lots of extra frontend functions by using a byte encoded stream
	  input to a function like print with escape codes as well as meta data (somewhat like how you
	  control a terminal)

Bugs:
	* there is a bug in stutter such that when there is a disconnect, stutter doesn't recognize it as
	  such and continues to select on that socket which returns -1 (i assume) which causes it to hog
	  all the bandwidth
	* fix parse so that /parse something command doesn't cause a segfault
	* in /names, if the channel doesn't have a window, the names aren't displayed anywhere
	* when server is down, there is no responsiveness and no way to break out; timeout is long
	* fix the long initial timeout (happens when network is disconnected) (remember that it tries to
	  connect 3 times).
	* there is a bug such that if you try to say something in the status window, the server says no such
	  nick

General:
	* finish implementing the new quit command
	* add something (a signal emitted by net perhaps) so that net can print messages, particularily a
	  "Failed to connect, Retrying" message
	* add a function to utils.c possibly that uses vsnprintf to make a string and then emits.  (This
	  will make reporting errors much easier).
	* fix up error handling in net.c and server.c
	* add the variable path resolution system back into variable.c (with both a get and set function)
	* add a function to key.c to get the current binding of a key sequence (without processing)
	* fix all hash_init and hash_rehash instances to check for memory allocation failure
	* fix history in input.c (the queue inline implementation cannot be used unless it is fixed because
	  if you store the "current" pointer and an append call deletes that node then you will get a
	  segfault.  The current node reference must either be stored in the queue struct or else the macro
	  implementation must be used).

	* add a cmd that takes a string in env and a string in args, merges them, and parses/evaluates it
	  as a command without the leading /
	* add an alias command which creates a new command with the given name using the above command as
	  the function and the args string as the string parameter (to become env)
	* add an unalias command that removes a command only so long as it has the form of an alias (has
	  the function twice above as the callback)

	* once and for all decide on the variable name seperator!
	* make variables and types case-insensitive
	* can we add partial variable (command) name matching?
	* add no-remove and no-change bitflags to variables (once they are set, they cannot be unset)
	* unify the naming patterns for namespace/variables, frontend widgets, etc.

	* pass realname to server when connecting
	* make msgs/join.c print a message when it fails to create a window
	* rewrite msg.c using va_args instead of making an array and use sprintf
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)
	* get realname, nick from current user's info (on unix)
	* would it be desirable to have msgs/names.c instead of ignoring users already added, update their
	  stats?  would this erase other bitflags that may have been set if they were just overwritten?
	* test multiserver functionality (more thuroughly?)

	* add mode command
	* add topic commnd (<channel> [<topic>])
	* add list command
	* add ping/whowas commands
	* add channel and user mode bits
	* add handling for CTCP commands
	* add reconnect command
	* add error message handling

	* change the name of screen.c to terminal.c
	* add home/end/erase-line functions to be keybound
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)
	* add multiframe (using multiple curses windows) to screen.c
	* decide on a widget interface to use in order to implement the advanced text frontend
	* what are the disadvantages of having frames store only the refresh callback?
	* catch the ^C signal and cancel a connect
	* document the required frontend things widgets (like window, input), things that can be passed
	  to fe_current...

	* use expand to buffer or something in irc_format_msg to convert variables *before* substituting
	  %% arguments

	* should i maintain a seperate changelog for each module, frontend, and the main program?

	* can have xml/javascript/flash displayed from a script somewhat like firefox extensions (except
	  hopefully in less files?) ???????????????????????

Features:
	* logging plugin
	* tab complete
	* winamp control and display plugin

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)


