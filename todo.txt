
Signals:
	* what if you store the channel struct pointer as the index?  there can be an irc-specific
	  method of finding the channel by assuming the index of an "irc-print" signal (or whatever it
	  will be called) is a channel struct but it would still need a method of searching all signal
	  handlers for "irc-print" for the current window pointer stored as the signal handler's
	  parameter.
	* a window handler connecting to a signal emitted for a particular window so that it can
	  free memory when that window is destroyed for example (server registering for its status
	  window and if a command like /close causes that window to be destroyed, the server disconnects
	  and frees all resources it uses)

Structural Issues:
	* how will you do timers?  they have to be implemented through the frontend.  Should a timeout
	  cause a signal to be emitted?  a callback (stored in the timer struct) to be called?  Could make
	  an 'events' system.
	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h
	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?) (a function in signals to delete
	  all signal handlers with a reference to a particular pointer?  will this possibly delete things
	  that its not suppose to since the pointer is not necessarily an address?) another possability is
	  to have a event/message/something signal handler for that pointer.
	* standardize the interpretation of the create type function parameters (the format string should
	  only ever contain a description of the arguments and should never be an argument itself)

	* the current/select functions can use the context as a partial type name lookup such that there
	  are special context names which correspond to special object "superclasses" such as 'frame' and
	  'input'.  Then when you specify something like 'frame' as the context, it means a general type of
	  widget.  ???
	* should you make the format parser function take a format_string_s pointer with the buffer and
	  array already set and with the max values so that it takes fewer arguments
	* how can you specify to a scroll widget which parser to use to parse the attributes out of strings
	  printed to that widget.
	* how will you draw the cursor? draw it yourself using a reverse colour attribute?
	* should colour schemes be largely frontend dependant?  we still need a way to specify colours.
	  one way could be to have variables in the frontend for various event/properties (standardized
	  across all frontends) with the value as a frontend-specific value which the frontend can recognize
	  and then strings printed to the frontend can use the variables (eg. "${fe.error}ERROR: ...${fe.fg}")
	* use the type system for widget types.  A widget is created from a type and subwidgets are added
	* how will widgets (like statusbar) be added, stored, accessed?  Will it be entirely frontend
	  specific or will it be through the variable system in which case a widget would be a variable
	  of the "widget" type.

	* should the stringify and evaluate type functions take a parameter (string or number?) to specify
	  the "type" of operation?  This for example, would let you get the real value and formatted value
	  of a format type or to specify the context of evaluation to avoid the /parse issue. 
	* what can be used as the index for network ready signals?  The network_t itself?  can we make
	  network signals better than the network callback we have now?
	* should we add a parent field to the variable?
	* should irc_send_msg dispatch the message (and thus dispatch all outbound messages?)
	* should we add a mechanism to signals that allows for signals to "inherit" from others so that
	  when a signal is emitted (irc channel) it also triggers another signal (like "general_msg") or
	  something which might making logging easier?  Can this be implemented as just a signal handler
	  that emits another signal in which case you can set the priority level at which the 'inherited'
	  signal is called (put the handler in signal.c even)?
	* change network_t to fe_network_t???

	* should the libs/ be moved to the root dir (since the primary issue was all the headers but now
	  that they are all inside include/stutter/ they wont conflict with system headers).
	* can we fix the /parse issue by making it take the string as a param instead and have a signal
	  handler that is called when the key is pressed that acutally get the input and calls parse?

Bugs:
	* when you connect and get a nick collision, it should either prompt you or change your nick auto
	  magically
	* if you change your nick while someone is connected to the same network with that nick then it
	  will change the nick (on the statusbar and thus in the server struct) and it isn't changed back
	  when the error message is received from the server
	* fix parse so that /parse something command doesn't cause a segfault
	* there is a bug such that if you try to say something in the status window, the server says no such
	  nick
	* the windows version sometimes hangs up when printing the motd and wont change the display but you
	  can still type and the statusbar updates.
	* when you quit sometimes it says broken pipe
	* history may not be working properly in the long run (it may fill up and stop) but look into it

General:

	* fix format so that it recognizes a closing ^C and restores the original colours
	* add cursor drawing to input by just drawing that character in reverse colours and getting the
	  curses terminal to turn off the cursor (what about multiple possible cursors on the screen)

	* we can use fe_resize to resize the root widget for a surface thus taking care of the resize issue.
	  Where would the resize take place?  During refresh?  
	* make a frontend/exec.h or frontend/execute.h implementation that is capable of running processes
	  in the background such that the input is available asyncronously.
	* change fe_read to return an int instead of char *
	* make user.c store the user names in a sorted list (linear_insert_sorted ??)

	* MAKE SURE all message handlers don't clobber the message!
	* fix all hash_init and hash_rehash instances to check for memory allocation failure
	* make an unknown ctcp message handler
	* add print handlers for the irc.error and base.error signals

	* report when a command fails
	* add something (a signal emitted by net perhaps) so that net can print messages, particularily a
	  "Failed to connect, Retrying" message
	* modify net.c to print a message when the connection times out and it retries.
	* fix up error handling in net.c and server.c
	* make the mode msg handler update the channel and user mode bits
	* look into the slow time it takes for the program to quit

	* have an "activity" status indicator in the status bar so you know when stuff has been said and
	  in what channels
	* have keybindings for targeting specific windows (does this require window numbers?)
	* get realname, nick from current user's info (on unix) (store in a "realname" variable?)
	* pass realname to server when connecting (base it on a "realname" variable?)
	* add list command
	* add whowas command
	* add kick command
	* add channel and user mode bits
	* add error message handling
	* add home/end functions to be keybound
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)
	* add a query feature so that you can talk to other users with your own window

	* add a type with an evaluate function that takes a string (stored) and a string in args, merges
	  them, and parses/evaluates it as a command
	* add an alias command which creates a new command with the given name using the above command as
	  the function and the args string as the string parameter (to become env)
	* add an unalias command that removes a command only so long as it has the form of an alias (has
	  the function twice above as the callback)

	* make common format.c more general in the format that it parses (specifiable parser function?)
	* move include files into an include/ directory inside of each module's directory (and then same
	  for frontends)
	* make a more cross platform way of getting ceratin values like username and user's homedir
	* make a configuration/compilation script that builds the makefiles
	* modify user.c and channel.c to use a hash table instead of the linear list
	* rewrite msg.c using va_args instead of making an array and use sprintf
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)
	* add a function to key.c to get the current binding of a key sequence (without processing)
	* do something with base/init.c and the loading of types

	* unify the naming patterns for variables and frontend widgets, etc.
	* can we fix the handling of the no remove flag in variables so that is doesn't remove the node
	  from the list before checking the flag and readding it when it finds it's not suppose to remove it?
	* would it be desirable to have msgs/names.c instead of ignoring users already added, update their
	  stats?  would this erase other bitflags that may have been set if they were just overwritten?
	* optimize for space and speed (re-evaluate things).
	* add the slab allocator
	* catch the ^C signal to cancel a connect
	* rewrite the simple frontend

Features:
	* logging plugin
	* winamp control and display plugin
	* add dcc support
	* ability to reorder windows

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)


