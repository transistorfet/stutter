
	* the object creation system and the variable system don't get along.  You are passing the va_list to
	  create_object which expects the list itself (...) which is causing all of your problems atm.  You
	  can either create a new shadow function to call instead from add_variable or you can change how
	  the variable system initializes objects/variables.  Keep in mind too that there is no established
	  reinitialization for variables with the new system anyways which sholud be part of the solution
	* important variable functions: set, stringify, evaulate (should all be able to operate on "subvar"
	  values.  important variable table functions: add, remove, index
	* should va_list functions use _real or _va as the mangle

	* how will signals work?  how will they be stored in the variable tables (a seperate signals table?)
	  how will the frontend know what signals to register to? perhaps a dedicated signals table with
	  common naming scheme based on function such as output.error, output.status, output.irc.philosophy,
	  create, create.irc (for notifying about the creation of a signal)
	* we can't do attrib/style/colour the way we were doing it using the new object system where we
	  pass the subparts of attrib to the appropriate type handler because those subparts aren't vars
	* seriously fix up string.c or even better get rid of it (make any function that can take a const
	  char * instead of a string_t (or at least a const string_t))

	* make sure non-fatal errors don't cause things to completely not work.  For example if the wildcard
	  thing isn't available, then don't prevent a normal lookup (i think that one is fixed already)
	* have a 'create' signal that tells the frontend that a new signal/data stream is available (possibly
	  even emitting this signal from an add_signal type function itself).  The frontend will then
	  create a new window (according to it's own programming/config)
	* how do you destroy a window/channel?  An IRC channel can be "disconnected" either by using the
	  leave/part command or by closing the window so either the irc module or the frontend must be able
	  to somehow destroy the whole thing (the channel struct and the window)
	* finish converting names in layout to the fe_ style and possibly rename it to "templates"
	* change colourmap to use the fe_ style names
	* make layout use the object system if it's an appropriate fit
	* decide on what to do about the purge_object signal
	* change names in frontend format.c (and refactor? should we use a different format like xml?)
	* make sure to remove all offset_after_struct_m references
	* convert the init.h macros to use static inlines for the actual code parts
	* should base.exec command be moved into the frontend?
	* should you replace type lookups such as in alias.c to directly referencing the type struct pointer?
	* replace while loops with for loops where possible
	* add a space after ; in for loops
	* attempt to reduce the number of crazy (stupid) widget control functions

	* what form will the init, add, and remove functions take?
	* params should be through a very simple single char per param string with "sfopn" string, function,
	  object, pointer, number

	* old bug: call to irc_format_parse_text with a NULL str from irc_format_msg on a /me message

	* should we move keybindings to the frontend (at least the common frontend)?
	* make everything stored in a variable be an object with a central object system
	* make timers more secure through the object system by making them objects themselves or making them
	  part of the objects they control (same with signals/hooks if we keep them around?)
	* we could possibly remove the frontend API completely and instead use commands and signals for
	  everything but that might be a bit too limiting, at least at this point
	* integrate the sdm interface system into stutter in place of the old desc/net system

	* should i change the name mangle from _s to something else for structs?
	* eliminate the callback struct in globals.h
	* change index_variable to something else that isn't confusing (conflicts with the index virtfunc)
	* replace all instances of fe_print with an emit_signal if possible
	* all signals should identify the module they come from but should it be a seperate param or a
	  single string param? ("base", "error") vs ("base.error")
	* add an is_a() check of the type in variable before trying to initialize or create a variable
	* move the key macros from init.h into something frontend-specific like frontend/common/init.h
	* finish converting base types timer and string-ref (unless you can merge it into string)
	* should you remove the _s designator from all modbase structs (the type structs)

	* there is still a bug in timer or something, after a reconnect, the value of cur (line 141) was
	  invalid, i assume from the timer being destroyed at some point.

	* i don't like the way signals are currently done, it seems too complex.  Or maybe it just needs
	  better safety and stability
	* maybe we can change the names/perspective of signals to "hooks"?
	* joinpoints are ugly and complex. can we fix this?
	* i don't like the way the irc msg dispatch works currently
	* i don't like the lack of isolation between the frontend and the rest of the system.  Can we
	  modify it so that all callbacks use the signals/hooks system (semitransparently perhaps, this might
	  require improvements in the signals/hooks functions).  It should be a simple matter to completely
	  detatch the frontend from the core although this might still require a basic frontend to convert
	  all calls between the 2 seperate processes into a datastream.


   ****** CHANGE THE WAY YOU DO POINTER ARITHMETIC! apparently i just need to do (ptr + 1) so long as ptr is
	  cast to the type i want to add

	* When a list is created, an offset is associated with it such that all items passed to the list
	  adjust for the offset
	* comparison/hash functions are defined in the module that includes the list header (?)

	* fix certain commands such as bind and perhaps context and many others to check for proper
	  parameters instead of attempting to evaluate the command anyways
	* if you make advice macros be inline functions instead, you have issue with the now missing semicolon
	  (but you can add a semicolon to the register joinpoint specifier)

	* move over to git
	* should, given git's submodule system, stutter's directory structure be changed so that modules can
	  be stored in git as submodules?

	* make it so that you can use stutter as a platform for writing command line utilies/servers so that
	  if you compile stutter a certain way, you can make a simple network server using a few config
	  options such as one to control a media player through exec and it's command line utilities. (ie.
	  sits on the network as a server and exec's commands as requests come in)

Structural Issues:

	* where should errors generally be printed from even using joinpoints?  Is it ok to have the net
	  code printing errors (in the case of the retries there isn't *that* much choice but perhaps there
	  is).  Would it be better for the command that attempts to connect to report the failure to connect
	  or should net_connect do that before it returns NULL?  (For example, the net.c's failed to connect
	  message is always printed before the unable to reconnect message when stutter is disconnected from
	  irc.)
	* can we use macros to implement the ability to set at compile time which parameters are compiled
	  in and which are modifiable variables?  how will we handle this for all the things in config.h
	* should you make a seperate include/ dir for each module/frontend?
	* can/should we make complex and/or expensive operations compile-time options (at least as long
	  as the operation can be disabled without causing trouble)? (like vim does with its FEAT_...)
	* should you move the commmon/utils headers to the include/ dir?
	* can you add special comments that a perl script can use to create at least part of the defaults.cfg
	  file?  Is this even a good idea?

	* you could have special variable tables like irc.on_msg where you add variables that are commands
	  and when a message comes in, it traverses all the variables in the table and evaluates them with
	  a particular formulation of parameters.  So you'd "/alias irc.on_msg.respond irc.say hey man"
	  to have it send "hey man" whenever you get a message.
	* make dispatch into a whole bunch of joinpoints? (what dispatch am i talking about?)  Oh i think
	  this is related to the evaluating of commands based on signals (make irc dispatch into joinpoints
	  with the default joinpoint being the message handler

	* where should the xml parser go?  in the frontend or the core?

    Core:

	* is there a way to have multiple layers of key contexts so for example, a global context and then
	  an irc context an irc:userlist context (for doing stuff inside of a userlist widget)? Could this
	  even be implemented without a structural change, just using context names with funny characters?
	  (If a key is not found in userlist:irc then it checks irc and then global).
	* can anything be done about the sorta messiness of the joinpoints?
	* should all instances of stringify that are accessable to the user do an index (path lookup) so
	  that all variables can be accessed indirectly and not just commands? (eg /get current_nick will
	  stringify "irc.current_nick")
	* should the stringify and evaluate type functions take a parameter (string or number?) to specify
	  the "type" of operation?  This for example, would let you get the real value and formatted value
	  of a format type.  For stringify it could be a string that specifies the format.  It could be
	  used by things like the nicks list for a channel where colour formatting can be added to the string
	  or you can choose to have the @ and + added as well
	* how do we handle the case where a pointer is stored with a callback and then the callback is
	  destroyed?  The pointer must also be destroyed at that point.  Even if it is stored in a list
	  it will never be needed again so even if we can access it, we have no way to know that we can
	  get rid of it.  This also applies to a second parameter supply to bind_key.  How will we destroy
	  it when a key binding is lost?  (Can typed values be used here?) (a function in signals to delete
	  all signal handlers with a reference to a particular pointer?  will this possibly delete things
	  that its not suppose to since the pointer is not necessarily an address?).  Another possibility is
	  sending an optional destroy function that can is called when a type is destroyed.  For things
	  where the pointer may be used multiple times but still needs to be destroyed, a simple refcount
	  can be used in the pointer and the destroy func.
	* should we make net and exec be able to have a different callback for each different condition?
	  (read/write/error/etc).
	* would it be totally bad to accept the parameters to emit as a va_list and store them in an array
	  of pointers that is passed to the handlers along with the size of the array?  Would this make
	  things too specific to a particular signal that is handled?  Is that a bad thing?
	* make bind key do the variable lookup itself but if you do, should you allow a path index lookup
	  or force all lookups to be absolute.  If you do that, you can still do path lookups by having
	  the /bind command use path.<name> for the command name (at least if no . is found).

    IRC Module:

	* should irc_send_msg dispatch the message (and thus dispatch all outbound messages? instead of just
	  dispatching select messages like privmsg and notice (which would require a rewrite of the message
	  handlers to check for an outbound message))

    Frontend:

	* can you make a special frontend/module pair such that the stutter core can be a daemon process and
	  you connect through a socket/dbus/something with a frontend version.  You then can use the frontend
	  locally or remotely to control the core where all the functionality is.
	* you could make the list a void * and type pair which means it can be tied to the variable tree but
	  it doesn't have to be.  The list widget would then want to do a traverse and stringify for each entry
	  which hopefully would do what is wanted.  Or should there be perhaps a more advanced list widget
	  that can collect bits of information into entries (ie. for an irc list of nicks in a channel, it
	  gets the list.name entry for the name and the list.is_op entry to decide if it should display a gold
	  star icon next to the entry) (either way it is an entirely frontend based system that uses a
	  list in the variable system with only the possibly of an unattached list needing direct input from
	  outside of the frontend).
	* how can you control a list widget such as a users list where names are added and deleted?  It could
	  be an variable (either assigned as a name that is looked up or as just a value and type (which means
	  it doesn't have to acutally be added to the variable list)) and then the traverse function is used
	  to get each item in the list and stringify is done on it.
	* should windows be able to have 2 or more names ("#philosophy", "1", "otherside/#philosophy") or
	  should it be able to have only one name and a number which can be easily changed so that windows
	  can be accessed by number and the order can be switched. (or both?)  Could we have all the names
	  in one string like "otherside/#philosophy,#philosophy".  It probably is possible to do this using
	  multiple entries for the same node in the table and using strstr or something to compare the names
	  after the hash number has been found.
	* how will multiple terminals work in curses?  how will input work with multiple terminal?

	* should there be 2 region widgets (one handling horizontal and one vertical organization) or should
	  there be one that handles both directions (but not necessarily at the same time)?
	* should you add a bunch of variables to the frontends which return common environment variables
	  and values such as the homedir and the current user's username?  should there also be a way to
	  access environment variables through a function and how would that be supported?
	* should the parameters to fe_resize be absolute sizes or differences in size?
	* what will happen to MODIFY_POSITION?  I can't see this being needed much but i guess it could be
	  so we could do the same thing as with MODIFY_SIZE
	* should there be a function in the fe that returns the id of a widget given a pointer to it?  Should
	  there be a way to change the id?  properties (such as title)?

	* how will you deal with adding a new widget?  There should be a way to specify (perhaps in the layout
	  if possible) where the new widget should be put (such as in a particularily named frame).  Then the
	  content portion does not need to know where the widget goes.  It could perhaps be a property in the
	  root widget's definition or perhaps a "special" layout type that instead of generating a widget,
	  creates a widget defined as a child and then adds it via the method specified in its properties
	* should all widgets inherit from a widget superclass?
	* should we disallow widgets to have the same id?  should we allow multiple ids and always add a
	  unique numbered id?  (this could cause a problem with the widget remove which at the moment uses
	  the id to find the widget).
	* how will you specify things like adding a widget to the current frame?  Who will add the widget
	  to the frame, how does it know to do that, and how will it have access to that?  Perhaps it can be
	  in the properties for the widget
	* perhaps you can add a sorta WCC_SET_INVISIBLE/WCC_SET_VISIBLE and have them set bitflags so that
	  it is easy to know if a widget is visible or not (and then you can do scrollbar things as well)
	* how will you initialize the target widget of input and how will you change/set the target widget?

	* region rejects widgets being added before we've resized it but that is causing some troubles with
	  initialization (you have to make region a non-zero size before adding widget).  Should region
	  instead allow widgets to be added when they don't fit or should you just size region before the
	  terminal resizes it properly?
 	* should a WCC_SET_SURFACE also cause a resize of everything in region?  at least if it is the root
	  or is it the job of the code that sets the surface to also do a resize?
	* how is the win32 config defs going to work?

Bugs:

	* there is a bug such that if you quit using the keybinding (^C^X) then it prints (null) as the
	  quit message instead of printing the default quit message

	* there is a bug such that a CTCP action message coming from freenode caused a NULL string to be
	  passed from irc_format_msg to irc_format_parse_text.  The NULL string was part of the CTCP struct
	  in the irc_msg struct.  The CTCP in queostion appears to have been \x01ACTION \0x1.  This appears
	  to be a parsing issue in msg.c

	* there is a bug such that if you try to say something in the status window, the server says no such
	  nick
	* when a character that is displayed with 2 characters is entered (such as ^C) the cursor is only
	  moved one character forward so when you enter more characters, they show up in further to the left
	  than expected
	* got some kind of infinite loop connected to freenode, in #logarithm, after testing logarithm with
	  stutter running on panther

	* stutter may be printing quit messages for users to channels where the user only partially matches
	  (logarithm_'s quit was reported when only logarithm was in the channel).
	* the Error Disconnected message is only printed for one server and is printed along with other
	  messages to the current window and not to windows properly associated with that server
	* is kick message handling working properly (it seems like stutter printed that logarithm quit in
	  #philosophy after he had been kicked and then quit).
	* in irc_private_msg and irc_notice (at least) there is a bug such that if the text is blank
	  ("/msg person") then it uses the constant "" and but the function tries to change it which causes
	  a segfault.

	* Overnight (2007-04-01 ~01:19) there was a segfault on turkey while reconnecting after a timeout.
	  Connected to otherside and freenode, in #philosophy, #coffeelounge, and #osdev with #philosophy
	  as the current channel.  The reconnect worked but a few seconds after rejoining the channel the
	  segfault occurred.
	* Segfault in text_print after allocating the node's memory, the node address appears to be non-zero
	  yet invalid (viewed in a coredump.  i have no idea why this would have happened)
	* segfaulty thing when there was a netsplit and we were doing an autoreconnect there was a segfault
	  at the actual call to shutdown() on the socket most likely because we forget to set server->net
	  to NULL at one point.

    Frontend:

	* the windows version sometimes hangs up when printing the motd and wont change the display but you
	  can still type and the statusbar updates.

General:

	* in types/command.c, evaluate function always returns -1 but i don't know why.  Is it a hack?
	* get doxygen working
	* work on API documentation

    Refactoring:

	* convert macros to the all caps scheme!
	* go through and make use of const where possible in parameters
	* consider converting bitflags to bitfield structs unioned with the bitflags (so that it's still
	  easy to copy them).
	* consider converting code to use constants and enums for some of the things that aren't configs
	* convert some of the modules that use linear lists to use the static inlines version of it instead
	* possibly change the naming scheme for types

    Config System:

	* can you make it possible to refer to #define values in values (variables) defined in the config
	* add the irc.version variable
	* add the ability to have duplicate "add" things (for handlers) (you need a way to pervent duplicate
	  entries where for example an option in enabled twice)
	* add type checking to the config script things (make sure values are a string with "" or a number
	  without and possibly automatically add semicolons to joinpoints)
	* add a simple makefile/.mk file output from the config script (since the config file has module and
	  frontend statements and therefore knows what to attempt to compile)
	* write a scripty thing to compile a list of all the default settings in the config scripts and write
	  them into a file as comments (a file that the user will edit) so that they know what options are
	  available
	* add a way to define widget layouts.  This might be a different system that uses XML

    IRC Module:

	* clean up irc server, especially try to combine the destruction of the server struct into a single
	  function (right now there is 2 destroys, one in release and one in destroy)

	* fix the version response (probably due to a missing irc.version variable)
	* make an irc key context
	* add channel and user mode bit stringification (probably through some kind of variable type)
	* add server name to notice messages
	* add traverse functions to the channel and user list types.
	* modify the irc types to return list types if referenced with direct names instead of returning NULL

	* make ping do milliseconds
	* modify channel.c to use a hash table instead of the linear list for storing users
	* distinguish between server and irc network? (a network is an "irc_server" with a list of server
	  addresses)

	* convert text.c and server.c/msg.c to use the new queue functions if it is easily possible
	* should irc_server_disconnect send the quit message (the quit message being passed to the function?)
	* get realname, nick from current user's info (on unix) (store in a "realname" variable?)
	* add an irc list command
	* pass realname to server when connecting (base it on a "realname" variable?)
	* add dcc support
	* add an active IRC ping thing

    Frontend:

	* modify fe.insert to allow escapes to insert unusual characters
	* fix text.c to properly display tab characters (perhaps you could modify irc_format_msg instead
	  to expand tabs and/or to filter out non-printable characters such as backspace and other control
	  codes)
	* add functions for insert_char, delete_char, move cursor, scroll history, etc (command variables)
	* add a beep (maybe using an fe_beep() function which is called from irc_format_msg)?
	* can you make the frontend colour type common colour names system a little nicer and fuller?
	* add a prompt to the input widget (that you can set through the variable system?)
	* make all the colour mappings reassignable
	* add UDP support to the net interface.
	* can you make a method of specifying windows (in order to select them) through numbers such that it
	  is possible to have key bindings for ALT-# keys to switch windows?
	* convert the terminal def_attrib variable to an attrib:fe type so you can set the style

	* have an "activity" status indicator in the status bar so you know when stuff has been said and
	  in what channels
	* add a function fe_prompt(char *prompt, char *buffer, int max) that prompts the user for input
	  by some appropriate frontend method (to be used for example to prompt yes or no when quitting)
	* finish/fix up region particularily the handling of MODIFY_SIZE and possibly re-write split
	* finish the fe_resize implementation in fe.c

	* fix up colour handling in curses/terminal.c (the add colour pair stuff)

	* add SCC_SET_FOCUS handler to win32 terminal
	* fix fonts in win32 fe (particularily adding the expression of the bold attribute)
	* implement execute.c for win32
	* add scrollwheel message handlers to the win32 frontend and use joinpoints to define the behaviour
	* finish implementing the win32 menu system
	* you can have a command "fe.dialogue <diag-name> <params>" in the win32 frontend that pops up a
	  dialogue by the given name (stored in a list probably by a dialogue.c manager in the core)

    Core:

	* add a way to get the current context name (perhaps through a variable)
	* add a find_next function to hash/linear/queue
	* add a version string
	* add unalias command
	* make a common method of identifying keys to be bound (particularily keys like home/end/etc)
	* do better parsing of arguments in execute.c
	* add a function to key.c to get the current binding of a key sequence (without processing)
	* make the disconnect error print to all windows instead of just the current one (using joinpoints)
	* add a system of returning common error codes from commands and printing generic error messages
	  for those commands common to all commands (such as command failed messages)

	* add a flag option to the quit command that causes it to prompt yes/no before quitting
	* make an online help system
	* can we fix the handling of the no remove flag in variables so that is doesn't remove the node
	  from the list before checking the flag and readding it when it finds it's not suppose to remove it?
	* optimize for space and speed (re-evaluate things).
	* add the slab allocator
	* catch the ^C signal to cancel a connect (make a way to interrupt an operation)
	* add a SIGWINCH handler to curses terminal
	* make an email checker timed event

	* make everything unicode/UTF-8 capable

Features:
	* logging plugin
	* winamp control and display plugin
	* ability to reorder windows
	* skins for frontends
	* jabber (other IM) modules
	* telnet module
	* file manager module/capability
	* shell capabilities

	* X11 frontend
	* jabber module?

	* scripting support (possible scripts/applets could be random picture displayer, system monitor,
	  RSS, etc) (google desktop)

Website:
	* add documentation to the website
	* add screenshots to your own website page
	* maybe make it look a bit more pretty?

